class mp3cutter{constructor(libPath="./lib/"){self.Mp3LameEncoderConfig={memoryInitializerPrefixURL:libPath,TOTAL_MEMORY:1073741824};this.libPath=libPath;var ref=document.getElementsByTagName("script")[0];var script=document.createElement("script");script.src=this.libPath+"Mp3LameEncoder.min.js";ref.parentNode.insertBefore(script,ref)}async cut(src,start,end,callback,bitrate=192){if(!src)throw"Invalid parameters!";if(start>end)throw"Start is bigger than end!";else if(start<0||end<0)throw"Start or end is negative, cannot process";let buffer=await new Response(src).arrayBuffer();let audioContext=new AudioContext;audioContext.decodeAudioData(buffer).then(function(decodedData){console.log(decodedData);let computedStart=decodedData.length*start/decodedData.duration;let computedEnd=decodedData.length*end/decodedData.duration;const newBuffer=audioContext.createBuffer(decodedData.numberOfChannels,computedEnd-computedStart,decodedData.sampleRate);for(var i=0;i<decodedData.numberOfChannels;i++){newBuffer.copyToChannel(decodedData.getChannelData(i).slice(computedStart,computedEnd),i)}console.log(newBuffer);let encoder=new Mp3LameEncoder(newBuffer.sampleRate,bitrate);let formattedArray={channels:Array.apply(null,{length:newBuffer.numberOfChannels-1-0+1}).map((v,i)=>i+0).map(i=>newBuffer.getChannelData(i)),sampleRate:newBuffer.sampleRate,length:newBuffer.length};console.log(formattedArray);encoder.encode(formattedArray.channels);let compressed_blob=encoder.finish();console.log(compressed_blob);console.log(URL.createObjectURL(compressed_blob));callback(compressed_blob)})}}